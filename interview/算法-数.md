#### 计算最大公约数
#### 计算最小公倍数
### 141. Sqrt(x)
Implement int sqrt(int x).  
Compute and return the square root of x.  
  
Example  
sqrt(3) = 1  
sqrt(4) = 2  
sqrt(5) = 2  
sqrt(10) = 3  
  
Challenge  
O(log(x))  
```Java
    /**
     * @param x: An integer
     * @return: The sqrt of x
     */
    public int sqrt(int x) {
        // write your code here
        /*暴力法*/
        /*
        int i=0;
        for(i=0; i*i<=x; ++i){
           if(i*i==x)
                return i;
        }
        return i-1;
        */
        
        
        long start=0;
        long end = x;
        long mid = 0;
        // if(start*start > x)
        //     return start;
        // else if(end*end <x)
        //     return end;
            
        while(start <= end){
            mid = (start+end) / 2;
            if(mid*mid==x)
                return (int)mid;
            else if(mid*mid < x)
                start = mid+1;
            else
                end = mid-1;
        }
        
        if(start*start > x)
            return  (int)start-1;
        else //if(end*end <x)
            return (int)end+1;
        
        
    }
```


### 1332. Number of 1 Bits
- Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight). 

- Example \
For example, the 32-bit integer 11 has binary representation 00000000000000000000000000001011, so the function should return 3.
```Java
  //解法1: 把n与1进行按位与，如果值是1，表明最后一位是1， 随后把n进行无符号右移，直到数字为0.
  public int hammingWeight(int n) {
        // write your code here
        if(n<0) return 0;
        int cnt = 0;
        while(n>0){
            if((n & 1) == 1)   
                ++cnt;
            n >>>=1;   //无符号右移
        }
        
        return cnt;
    }
    
    //解法2: 利用n&(n-1)作用：将n的二进制表示中的最低位为1的改为0
    
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        if (n == 0) {
            return 0;
        }
        
        int count = 1;
        while ((n & (n - 1)) != 0) {
            n &= n-1;
            count++;
        }
        return count;
    }
  
```


### 413. Reverse Integer  
Reverse digits of an integer. Returns 0 when the reversed integer overflows (signed 32-bit integer).  
  
Example  
Given x = 123, return 321  
Given x = -123, return -321  
```Java
    /**
     * @param n: the integer to be reversed
     * @return: the reversed integer
     */
    public int reverseInteger(int n) {
        // write your code here
        int result = 0;
        while(n != 0){
            int temp = result * 10 + n%10;  //每次循环先把原先的result*10， 然后加上剩余n的个位数字（取模）。
            n /= 10;
            //关键步骤
            //若*10之后的数再/10得不到原来的数，则说明已经溢出（-2^32~2^32）   
            if(temp / 10 != result){
                result = 0;
                break;
            }else{
                result = temp;
            }
        }
        
        return result;
    }
```


### 56. Two Sum
Given an array of integers, find two numbers such that they add up to a specific target number.  

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are zero-based.  

Example  
numbers=[2, 7, 11, 15], target=9  
return [0, 1]  

Challenge  
Either of the following solutions are acceptable:  
O(n) Space, O(nlogn) Time  
O(n) Space, O(n) Time  
Notice  
You may assume that each input would have exactly one solution  
```Java
    /**
     * @param numbers: An array of Integer
     * @param target: target = numbers[index1] + numbers[index2]
     * @return: [index1, index2] (index1 < index2)
     *
     * 思路： 找a[i]+a[j] = target, 等价于在a[i+1, length] 中查找target-a[i]
     * 二分查找的时间复杂度为O(lgN)
     * 加上外部的遍历，总的时间复杂度为O(NlgN)
     */
     //二分查找
    public int binarySearch(int key, int[] array, int low, int high){
        if(array == null) return -1;

        if(low > high) return -1;

        int mid = (low+high)/2;
        if(array[mid] == key) return mid;
        else return binarySearch(key, array, low, mid-1)+binarySearch(key, array, mid+1, high)+1;

    }
    //
    public int[] twoSum(int[] numbers, int target) {
        // write your code here
        //sort array for binary search purpose
        if(numbers == null || numbers.length == 0) return null;
        // Arrays.sort(numbers);
        //int result[] = new int[2];
        for(int i=0;i<numbers.length;i++){
            //result[0] = i;
            int xIndex =  binarySearch(target-numbers[i], numbers, i+1, numbers.length-1);
            if(xIndex >i){
                //result[1] = xIndex;
                //return result;
                return new int[]{i, xIndex};
            }

        }
        return null;

    }
    
    /*
     * 思路： 把target-numbers[i]存入一个Map中，每次遍历检查numbers[i]是否存在与这个Map中，若存在表明两者相加的和为target
     */
     public int[] twoSum(int[] numbers, int target) {
        // write your code here
        Map<Integer, Integer> tmap = new HashMap<Interger,Integer>();
        
        for(int i=0; i<numbers.length; i++){
            if(tmap.containsKey(number[i])){
                return new int[]{i, tmap.get(number[i]));
            }
            
            tmap.put(target-number[i], i);
        }
        
        return null
     }
    
```

### 111. Climbing Stairs
You are climbing a stair case. It takes n steps to reach to the top.  
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?  
  
Example  
Given an example n=3 , 1+1+1=2+1=1+2=3  
return 3  
  
  
```Java
    /**
     * @param n: An integer
     * @return: An integer
     * 思路：f[i] = f[i -2]+f[i-1], 注意, 从i - 2层跳1步再跳1步的这个走法, 已经包含在跳到第i-1层的走法里了, 所以不需要重复去加一次.
     */
    public int climbStairs(int n) {
        // write your code here
        
        if(n == 0) return 0;
        if(n == 1) return 1;
        if(n == 2) return 2;
        if(n>2) 
            return climbStairs(n-1)+climbStairs(n-2);
        else
            return 0;
            
            
        /*
        if(n == 0) return 0;
        if(n == 1) return 1;
        if(n == 2) return 2;
        
        int prevPrev = 1;  //1
        int prev = 2;
        int sum = 0;
        for (int i = 3; i <= n; i++) {
            sum = prevPrev + prev;
            prevPrev = prev;
            prev = sum;
        }
        return sum;
        */
        
    }
```


### 判定一个数是否是素数
```Java
/*
素数: 质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数
分析： 
    条件1：大于1
    条件2: 小于自身
    条件3: 不能被条件1和条件2之间的数整除 -> x%i != 0 for (0<i<N) -> x%i != 0 for (1<powser(i,2)<N)
*/
public static boolean isPrime(int N)
{
    if (N < 2) return false;
    for (int i = 2; i*i <= N; i++)  
        if (N % i == 0) return false;
    return true;
}
```
### 计算平方根(牛顿迭代法)  ?
```Java
public static double sqrt(double c)
{
    if (c < 0) return Double.NaN;
    double err = 1e-15;
    double t = c;
    while (Math.abs(t - c/t) > err * t)
        t = (c/t + t) / 2.0;
    return t;
}
```
### 计算调和级数
