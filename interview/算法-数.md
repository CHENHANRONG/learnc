#### 计算最大公约数
#### 计算最小公倍数
#### 56. Two Sum
Given an array of integers, find two numbers such that they add up to a specific target number.  

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are zero-based.  

Example  
numbers=[2, 7, 11, 15], target=9  
return [0, 1]  

Challenge  
Either of the following solutions are acceptable:  
O(n) Space, O(nlogn) Time  
O(n) Space, O(n) Time  
Notice  
You may assume that each input would have exactly one solution  
```Java
    /**
     * @param numbers: An array of Integer
     * @param target: target = numbers[index1] + numbers[index2]
     * @return: [index1, index2] (index1 < index2)
     *
     * 思路： 找a[i]+a[j] = target, 等价于在a[i+1, length] 中查找target-a[i]
     * 二分查找的时间复杂度为O(lgN)
     * 加上外部的遍历，总的时间复杂度为O(NlgN)
     */
     //二分查找
    public int binarySearch(int key, int[] array, int low, int high){
        if(array == null) return -1;

        if(low > high) return -1;

        int mid = (low+high)/2;
        if(array[mid] == key) return mid;
        else return binarySearch(key, array, low, mid-1)+binarySearch(key, array, mid+1, high)+1;

    }
    //
    public int[] twoSum(int[] numbers, int target) {
        // write your code here
        //sort array for binary search purpose
        if(numbers == null || numbers.length == 0) return null;
        // Arrays.sort(numbers);
        //int result[] = new int[2];
        for(int i=0;i<numbers.length;i++){
            //result[0] = i;
            int xIndex =  binarySearch(target-numbers[i], numbers, i+1, numbers.length-1);
            if(xIndex >i){
                //result[1] = xIndex;
                //return result;
                return new int[]{i, xIndex};
            }

        }
        return null;

    }
    
    /*
     * 思路： 把target-numbers[i]存入一个Map中，每次遍历检查numbers[i]是否存在与这个Map中，若存在表明两者相加的和为target
     */
     public int[] twoSum(int[] numbers, int target) {
        // write your code here
        Map<Integer, Integer> tmap = new HashMap<Interger,Integer>();
        
        for(int i=0; i<numbers.length; i++){
            if(tmap.containsKey(number[i])){
                return new int[]{i, tmap.get(number[i]));
            }
            
            tmap.put(target-number[i], i);
        }
        
        return null
     }
    
```



#### 判定一个数是否是素数
```Java
/*
素数: 质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数
分析： 
    条件1：大于1
    条件2: 小于自身
    条件3: 不能被条件1和条件2之间的数整除 -> x%i != 0 for (0<i<N) -> x%i != 0 for (1<powser(i,2)<N)
*/
public static boolean isPrime(int N)
{
    if (N < 2) return false;
    for (int i = 2; i*i <= N; i++)  
        if (N % i == 0) return false;
    return true;
}
```
#### 计算平方根(牛顿迭代法)  ?
```Java
public static double sqrt(double c)
{
    if (c < 0) return Double.NaN;
    double err = 1e-15;
    double t = c;
    while (Math.abs(t - c/t) > err * t)
        t = (c/t + t) / 2.0;
    return t;
}
```
#### 计算调和级数
