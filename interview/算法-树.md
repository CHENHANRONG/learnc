
# 树
## 树的存储结构
1. 顺序存储：将数据结构存在一块固定的数组中。 虽然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。
2. 链式存储.


## 树的问题一般考虑用递归、栈来解决
## 递归的编写考虑三个问题： 1. 退出条件； 2: f(n) 与 f(n-1)的关系，是先递归再处理，还是先处理再递归 ； 3: 初试状态

## 树的遍历
### 深度遍历：
- 遍历即将树的所有结点访问且仅访问一次。按照根节点位置的不同分为前序遍历，中序遍历，后序遍历。
  - 前序遍历：根节点->左子树->右子树
  - 中序遍历：左子树->根节点->右子树
  - 后序遍历：左子树->右子树->根节点
- 遍历的实现：
  - 递归实现
    ```C++
    // pre-order
    void preorder(bintree t){
        if(t){
            printf("%c ",t->data);
            preorder(t->lchild);
            preorder(t->rchild);
        }
    }
    // mid-order
     void midorder(bintree t){
        if(t){
            postorder(t->lchild);
            printf("%c ",t->data);
            postorder(t->rchild);
        }
    }
    // post-order
     void postorder(bintree t){
        if(t){
            postorder(t->lchild);
            postorder(t->rchild);
            printf("%c ",t->data);
        }
    }

    // 

  - 非递归实现
    ```C++
    
    ```



  ```

### 广度遍历





### 480. Binary Tree Paths
Given a binary tree, return all root-to-leaf paths.  
  
Example  
Given the following binary tree:  

   1  
 /   \  
2     3  
 \  
  5  
All root-to-leaf paths are:  
  
["1->2->5","1->3"]  
```Java

/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
 
    /**
     * @param root: the root of the binary tree
     * @return: all root-to-leaf paths
     */
    public List<String> binaryTreePaths(TreeNode root) {
        // write your code here
        
        List<String> result = new ArrayList<String>();
         
        if(root == null) 
            return result;
        
        getBinaryTreePaths(result, root,  String.valueOf(root.val));
        
        return result;
    }
    
    
    private void getBinaryTreePaths(List<String> result, TreeNode node, String strPath){
        if(node.left == null && node.right == null){
            result.add(strPath);
        }
        
        if(node.left != null){
            getBinaryTreePaths(result, node.left, strPath+"->"+node.left.val);
        }
        
        if(node.right != null){
            getBinaryTreePaths(result, node.right , strPath+"->"+node.right.val);
        }
    }

```

### 97. Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.  
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  
  
Example  
Given a binary tree as follow:  
  
  1  
 / \   
2   3  
   / \  
  4   5    
The maximum depth is 3.  
```Java 
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */

    public int maxDepth(TreeNode root) {
        // write your code here
        if(root == null){
            return 0;
        }
         return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```
