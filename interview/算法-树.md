
# 树
## 树的存储结构
1. 顺序存储：将数据结构存在一块固定的数组中。 虽然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。
2. 链式存储.


## 树的问题一般考虑用递归、栈来解决
## 递归的编写考虑三个问题： 1. 退出条件； 2: f(n) 与 f(n-1)的关系，是先递归再处理，还是先处理再递归 ； 3: 初试状态

## 树的遍历
### 深度遍历：
- 遍历即将树的所有结点访问且仅访问一次。按照根节点位置的不同分为前序遍历，中序遍历，后序遍历。
  - 前序遍历：根节点->左子树->右子树
  - 中序遍历：左子树->根节点->右子树
  - 后序遍历：左子树->右子树->根节点
- 遍历的实现：
  - 递归实现
    ```C++
    // pre-order
    void preorder(bintree t){
        if(t){
            printf("%c ",t->data);
            preorder(t->lchild);
            preorder(t->rchild);
        }
    }
    // mid-order
     void midorder(bintree t){
        if(t){
            postorder(t->lchild);
            printf("%c ",t->data);
            postorder(t->rchild);
        }
    }
    // post-order
     void postorder(bintree t){
        if(t){
            postorder(t->lchild);
            postorder(t->rchild);
            printf("%c ",t->data);
        }
    }

    // 

  - 非递归实现
    ```C++
    //因为当遍历过根节点之后还要回来，所以必须将其存起来。考虑到后进先出的特点，选用栈存储。数量确定，以顺序栈存储。
    
    #define SIZE 100
    typedef struct seqstack{
        bintree data[SIZE];
        int tag[SIZE];   //为后续遍历准备的
        int top;     //top为数组的下标
    }seqstack;
 
    void push(seqstack *s,bintree t){

        if(s->top == SIZE){
            printf("the stack is full\n");
        }else{
            s->top++;
            s->data[s->top]=t;
        }
    }
 
    bintree pop(seqstack *s){
        if(s->top == -1){
            return NULL;
        }else{
            s->top--;
            return s->data[s->top+1];
        }
    }
    
    // preorder 
    void preorder_dev(bintree t){
        seqstack s;
        s.top = -1;     //因为top在这里表示了数组中的位置，所以空为-1
        if(!t){
            printf("the tree is empty\n");
        }else{
            while(t || s.stop != -1){
                while(t){    //只要结点不为空就应该入栈保存，与其左右结点无关    
                      printf("%c ",t->data);
                    push(&s,t);
                    t= t->lchild;
                }
                t=pop(&s);
                t=t->rchild;
            }
        }
    }
    ```



  ```

### 广度遍历
- 层次遍历：即每一层从左向右输出, 元素需要储存有先进先出的特性，所以选用队列存储。




### 480. Binary Tree Paths
Given a binary tree, return all root-to-leaf paths.  
  
Example  
Given the following binary tree:  

   1  
 /   \  
2     3  
 \  
  5  
All root-to-leaf paths are:  
  
["1->2->5","1->3"]  
```Java

/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
 
    /**
     * @param root: the root of the binary tree
     * @return: all root-to-leaf paths
     */
    public List<String> binaryTreePaths(TreeNode root) {
        // write your code here
        
        List<String> result = new ArrayList<String>();
         
        if(root == null) 
            return result;
        
        getBinaryTreePaths(result, root,  String.valueOf(root.val));
        
        return result;
    }
    
    
    private void getBinaryTreePaths(List<String> result, TreeNode node, String strPath){
        if(node.left == null && node.right == null){
            result.add(strPath);
        }
        
        if(node.left != null){
            getBinaryTreePaths(result, node.left, strPath+"->"+node.left.val);
        }
        
        if(node.right != null){
            getBinaryTreePaths(result, node.right , strPath+"->"+node.right.val);
        }
    }

```

### 97. Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.  
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  
  
Example  
Given a binary tree as follow:  
  
  1  
 / \   
2   3  
   / \  
  4   5    
The maximum depth is 3.  
```Java 
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */

    public int maxDepth(TreeNode root) {
        // write your code here
        if(root == null){
            return 0;
        }
         return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```
