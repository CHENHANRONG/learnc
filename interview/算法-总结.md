
### 算法分析中的常见函数
![](http://latex.codecogs.com/gif.latex?\frac{1}{1+sin(x)}）

![Commonly encountered functions in the analysis of algorithms](https://github.com/CHENHANRONG/learnc/blob/master/resource/images/Algorithm/Commonly%20encountered%20functions%20in%20the%20analysis%20of%20algorithms.png)


### 算法分析中常用的近似函数
![Useful approximations for the analysis of algorithms](https://github.com/CHENHANRONG/learnc/blob/master/resource/images/Algorithm/Useful%20approximations%20for%20the%20analysis%20of%20algorithms.png)

### 确定运行时间的数学模型的步骤 developing a mathematical model of running time
For many programs, developing a mathematical model of running time reduces to the following steps:  \
- Develop an **input model**, including a definition of the **problem size**.  （输入规模）
- Identify the **inner loop**. （内循环）
- Define a **cost model** that includes operations in the inner loop.  （成本模型）
- Determine the **frequency of execution** of those operations for the given input. （执行频率）  
其中：  
**cost model**：defines the basic operations used by the algorithms we are studying to solve the problem at hand. 

#### 递归
- 用数学归纳法证明递归.
- 使用递归的另一个原因是我们可以使用数学模型的来估计程序的性能。
- 编写递归代码时最重要的有以下三点。
  1. 递归总有一个最简单的情况——方法的第一条语句总是一个包含 return 的条件语句。
  1. 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。
  1. 递归调用的父问题和尝试解决的子问题之间不应该有交集。
```Java
/* 二分查找的递归实现*/
public static int rank(int key, int[] a, int lo, int hi) { //如果key存在于a[]中，它的索引不会小于lo且不会大于hi
   if (lo > hi) return -1;
   int mid = lo + (hi - lo) / 2;
   if (key < a[mid]) return rank(key, a, lo, mid - 1);
   else if (key > a[mid]) return rank(key, a, mid + 1, hi);
   else return mid;
}
```
#### 队列 queues：FIFO
- first- in-first-out (FIFO)
- 基于公平原则，先来先服务。

#### 栈 stacks：LIFO
- last-in-first-out (LIFO)
